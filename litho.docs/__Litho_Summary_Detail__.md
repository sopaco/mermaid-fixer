# é¡¹ç›®åˆ†ææ€»ç»“æŠ¥å‘Šï¼ˆå®Œæ•´ç‰ˆï¼‰

ç”Ÿæˆæ—¶é—´: 2025-09-28 08:16:49 UTC

## æ‰§è¡Œè€—æ—¶ç»Ÿè®¡

- **æ€»æ‰§è¡Œæ—¶é—´**: 363.19 ç§’
- **é¢„å¤„ç†é˜¶æ®µ**: 0.11 ç§’ (0.0%)
- **ç ”ç©¶é˜¶æ®µ**: 65.77 ç§’ (18.1%)
- **æ–‡æ¡£ç”Ÿæˆé˜¶æ®µ**: 297.30 ç§’ (81.9%)
- **è¾“å‡ºé˜¶æ®µ**: 0.00 ç§’ (0.0%)
- **Summaryç”Ÿæˆæ—¶é—´**: 0.001 ç§’

## ç¼“å­˜æ€§èƒ½ç»Ÿè®¡ä¸èŠ‚çº¦æ•ˆæœ

### æ€§èƒ½æŒ‡æ ‡
- **ç¼“å­˜å‘½ä¸­ç‡**: 58.3%
- **æ€»æ“ä½œæ¬¡æ•°**: 24
- **ç¼“å­˜å‘½ä¸­**: 14 æ¬¡
- **ç¼“å­˜æœªå‘½ä¸­**: 10 æ¬¡
- **ç¼“å­˜å†™å…¥**: 11 æ¬¡

### èŠ‚çº¦æ•ˆæœ
- **èŠ‚çœæ¨ç†æ—¶é—´**: 62.1 ç§’
- **èŠ‚çœTokenæ•°é‡**: 16746 è¾“å…¥ + 7614 è¾“å‡º = 24360 æ€»è®¡
- **ä¼°ç®—èŠ‚çœæˆæœ¬**: $0.0130
- **æ€§èƒ½æå‡**: 58.3%
- **æ•ˆç‡æå‡æ¯”**: 0.2xï¼ˆèŠ‚çœæ—¶é—´ / å®é™…æ‰§è¡Œæ—¶é—´ï¼‰

## æ ¸å¿ƒè°ƒç ”æ•°æ®æ±‡æ€»

æ ¹æ®Promptæ¨¡æ¿æ•°æ®æ•´åˆè§„åˆ™ï¼Œä»¥ä¸‹ä¸ºå››ç±»è°ƒç ”ææ–™çš„å®Œæ•´å†…å®¹ï¼š

### ç³»ç»Ÿä¸Šä¸‹æ–‡è°ƒç ”æŠ¥å‘Š
æä¾›é¡¹ç›®çš„æ ¸å¿ƒç›®æ ‡ã€ç”¨æˆ·è§’è‰²å’Œç³»ç»Ÿè¾¹ç•Œä¿¡æ¯ã€‚

```json
{
  "business_value": "è‡ªåŠ¨åŒ–ä¿®å¤æŠ€æœ¯æ–‡æ¡£ä¸­çš„ Mermaid å›¾è¡¨é”™è¯¯ï¼Œå‡å°‘äººå·¥å®¡æŸ¥æˆæœ¬ï¼Œæå‡æ–‡æ¡£ä¸€è‡´æ€§ä¸å¯è¯»æ€§ï¼Œé€‚ç”¨äºå¤§è§„æ¨¡æ–‡æ¡£åº“çš„ CI/CD æµç¨‹é›†æˆã€‚",
  "confidence_score": 0.95,
  "external_systems": [
    {
      "description": "æä¾› AI ä¿®å¤èƒ½åŠ›çš„è¿œç¨‹å¤§è¯­è¨€æ¨¡å‹æœåŠ¡ï¼Œæ¥æ”¶ Mermaid ä»£ç ç‰‡æ®µå¹¶è¿”å›ä¿®å¤åçš„ç‰ˆæœ¬ã€‚",
      "interaction_type": "HTTP API è°ƒç”¨",
      "name": "LLM APIï¼ˆå¦‚ Mistralï¼‰"
    },
    {
      "description": "å­˜å‚¨ Markdown æ–‡ä»¶å’Œé…ç½®æ–‡ä»¶ï¼ˆconfig.tomlï¼‰çš„æœ¬åœ°ç£ç›˜ç³»ç»Ÿã€‚",
      "interaction_type": "æ–‡ä»¶è¯»å†™",
      "name": "æ–‡ä»¶ç³»ç»Ÿ"
    },
    {
      "description": "ç”¨äºæ³¨å…¥æ•æ„Ÿé…ç½®ï¼ˆå¦‚ API å¯†é’¥ï¼‰çš„è¿è¡Œæ—¶ç¯å¢ƒã€‚",
      "interaction_type": "ç¯å¢ƒå˜é‡è¯»å–",
      "name": "ç¯å¢ƒå˜é‡"
    }
  ],
  "project_description": "ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ï¼Œç”¨äºè‡ªåŠ¨æ‰«æã€éªŒè¯å’Œä¿®å¤ Markdown æ–‡ä»¶ä¸­çš„ Mermaid å›¾è¡¨ä»£ç å—ï¼Œé€šè¿‡ AI èƒ½åŠ›æ™ºèƒ½ä¿®å¤è¯­æ³•é”™è¯¯ï¼Œæå‡æŠ€æœ¯æ–‡æ¡£è´¨é‡ã€‚",
  "project_name": "mermaid-fixer",
  "project_type": "CLITool",
  "system_boundary": {
    "excluded_components": [
      "Mermaid æ¸²æŸ“å¼•æ“ï¼ˆä»…é€šè¿‡ mermaid-rs åº“é—´æ¥ä½¿ç”¨ï¼‰",
      "Web UI æˆ–å›¾å½¢ç•Œé¢",
      "æ•°æ®åº“æˆ–æŒä¹…åŒ–å­˜å‚¨",
      "ç”¨æˆ·è®¤è¯ç³»ç»Ÿ",
      "ç½‘ç»œæœåŠ¡ç«¯ç‚¹",
      "å®æ—¶åä½œåŠŸèƒ½"
    ],
    "included_components": [
      "CLI å‚æ•°è§£æå™¨",
      "é…ç½®åŠ è½½å™¨",
      "Markdown æ–‡ä»¶æ‰«æå™¨",
      "Mermaid è¯­æ³•éªŒè¯å™¨",
      "AI ä¿®å¤ä»£ç†",
      "ç»Ÿè®¡è¾“å‡ºå·¥å…·"
    ],
    "scope": "ä¸€ä¸ªæœ¬åœ°å‘½ä»¤è¡Œå·¥å…·ï¼Œä¸“æ³¨äº Markdown æ–‡æ¡£ä¸­ Mermaid å›¾è¡¨çš„æ‰«æã€éªŒè¯ä¸æ™ºèƒ½ä¿®å¤ã€‚"
  },
  "target_users": [
    {
      "description": "è´Ÿè´£ç¼–å†™å’Œç»´æŠ¤æŠ€æœ¯æ–‡æ¡£çš„å·¥ç¨‹å¸ˆï¼Œç»å¸¸ä½¿ç”¨ Mermaid ç»˜åˆ¶æ¶æ„å›¾ã€æµç¨‹å›¾ç­‰ã€‚",
      "name": "æŠ€æœ¯æ–‡æ¡£å·¥ç¨‹å¸ˆ",
      "needs": [
        "å¿«é€Ÿå‘ç°å¹¶ä¿®å¤ Mermaid å›¾è¡¨è¯­æ³•é”™è¯¯",
        "æ‰¹é‡å¤„ç†å¤šä¸ª Markdown æ–‡ä»¶",
        "é›†æˆåˆ°è‡ªåŠ¨åŒ–æ„å»ºæµç¨‹ä¸­"
      ]
    },
    {
      "description": "åœ¨é¡¹ç›®ä¸­ç¼–å†™æŠ€æœ¯æ–‡æ¡£çš„å¼€å‘äººå‘˜ï¼Œå¸Œæœ›å‡å°‘æ‰‹åŠ¨è°ƒè¯•å›¾è¡¨çš„æ—¶é—´ã€‚",
      "name": "å¼€å‘è€…",
      "needs": [
        "åœ¨æœ¬åœ°æˆ– CI ç¯å¢ƒä¸­è‡ªåŠ¨æ£€æŸ¥æ–‡æ¡£æœ‰æ•ˆæ€§",
        "è·å¾—æ¸…æ™°çš„é”™è¯¯æŠ¥å‘Šå’Œä¿®å¤å»ºè®®",
        "æ”¯æŒè‡ªå®šä¹‰ LLM æ¨¡å‹å’Œ API é…ç½®"
      ]
    }
  ]
}
```

### é¢†åŸŸæ¨¡å—è°ƒç ”æŠ¥å‘Š
æä¾›é«˜å±‚æ¬¡çš„é¢†åŸŸåˆ’åˆ†ã€æ¨¡å—å…³ç³»å’Œæ ¸å¿ƒä¸šåŠ¡æµç¨‹ä¿¡æ¯ã€‚

```json
{
  "architecture_summary": "mermaid-fixer æ˜¯ä¸€ä¸ªè½»é‡çº§å‘½ä»¤è¡Œå·¥å…·ï¼Œé‡‡ç”¨æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯â€˜é…ç½®é©±åŠ¨ + èŒè´£åˆ†ç¦»â€™ã€‚ç³»ç»Ÿä»¥ main ä¸ºå¯åŠ¨ä¸­æ¢ï¼Œé€šè¿‡ CLI è§£æç”¨æˆ·è¾“å…¥ï¼ŒåŠ è½½é…ç½®ï¼Œåè°ƒå¤šä¸ªç‹¬ç«‹åŠŸèƒ½æ¨¡å—å®Œæˆæ–‡æ¡£ä¿®å¤ä»»åŠ¡ã€‚å„æ¨¡å—é—´é€šè¿‡æ¸…æ™°çš„æ¥å£è§£è€¦ï¼Œä¾èµ–å…³ç³»å•å‘ã€æ˜ç¡®ï¼Œå½¢æˆâ€˜å…¥å£-é…ç½®-å¤„ç†-å·¥å…·â€™çš„å±‚æ¬¡åŒ–ç»“æ„ã€‚æŠ€æœ¯é€‰å‹ä¸Šä½¿ç”¨ Rust çš„æ ‡å‡†åº“ä¸ serdeã€clapã€mermaid-rs ç­‰æˆç†Ÿç”Ÿæ€åº“ï¼Œç¡®ä¿é«˜æ€§èƒ½ä¸å¯ç»´æŠ¤æ€§ï¼Œé€‚åˆé›†æˆè‡³ CI/CD æµç¨‹ã€‚",
  "business_flows": [
    {
      "description": "ç”¨æˆ·é€šè¿‡å‘½ä»¤è¡ŒæŒ‡å®šç›®å½•ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‰«ææ‰€æœ‰ Markdown æ–‡ä»¶ï¼Œæå–å…¶ä¸­çš„ Mermaid å›¾è¡¨ï¼ŒéªŒè¯è¯­æ³•æœ‰æ•ˆæ€§ï¼Œå¹¶å¯¹æ— æ•ˆå›¾è¡¨è°ƒç”¨ AI æ¨¡å‹è¿›è¡Œæ™ºèƒ½ä¿®å¤ï¼Œæœ€ç»ˆè¾“å‡ºç»Ÿè®¡æŠ¥å‘Šã€‚è¯¥æµç¨‹æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒä»·å€¼è·¯å¾„ï¼Œç›´æ¥å®ç°è‡ªåŠ¨åŒ–æ–‡æ¡£è´¨é‡æå‡ã€‚",
      "entry_point": "å‘½ä»¤è¡Œæ‰§è¡Œ `mermaid-fixer --path <dir>`",
      "importance": 10.0,
      "involved_domains_count": 5,
      "name": "Mermaid æ–‡æ¡£æ‰¹é‡ä¿®å¤æµç¨‹",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "é…ç½®ç®¡ç†åŸŸ",
          "operation": "è§£æå‘½ä»¤è¡Œå‚æ•°å¹¶åŠ è½½ config.toml é…ç½®æ–‡ä»¶ï¼Œåˆå¹¶ç¯å¢ƒå˜é‡è¦†ç›–ï¼Œç”Ÿæˆæœ€ç»ˆé…ç½®å¯¹è±¡",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "æ–‡ä»¶æ‰«æåŸŸ",
          "operation": "é€’å½’æ‰«ææŒ‡å®šç›®å½•ï¼Œè¿‡æ»¤é Markdown æ–‡ä»¶ï¼Œæ”¶é›†æ‰€æœ‰ .md å’Œ .markdown æ–‡ä»¶è·¯å¾„",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "è¯­æ³•éªŒè¯åŸŸ",
          "operation": "é€ä¸ªè¯»å– Markdown æ–‡ä»¶å†…å®¹ï¼Œæå–æ‰€æœ‰ ```mermaid ä»£ç å—ï¼Œè°ƒç”¨ MermaidValidator è¿›è¡Œè¯­æ³•éªŒè¯å¹¶åˆ†ç±»é”™è¯¯ç±»å‹",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "AIä¿®å¤åŸŸ",
          "operation": "åœ¨éå¹²è¿è¡Œæ¨¡å¼ä¸‹ï¼Œå¯¹éªŒè¯å¤±è´¥çš„ Mermaid ä»£ç å—ï¼Œè°ƒç”¨ AiFixer å‘è¿œç¨‹ LLM API å‘é€ä¿®å¤è¯·æ±‚ï¼Œè§£æå“åº”å¹¶è·å–ä¿®å¤åä»£ç ",
          "step": 4,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "å¤„ç†åè°ƒåŸŸ",
          "operation": "å°†ä¿®å¤åçš„ä»£ç å†™å›åŸæ–‡ä»¶ï¼ˆè‹¥å¯ç”¨ï¼‰ï¼Œå¹¶æ±‡æ€»å¤„ç†ç»Ÿè®¡ä¿¡æ¯ï¼Œé€šè¿‡ utils æ¨¡å—æ ¼å¼åŒ–è¾“å‡ºç»“æœ",
          "step": 5,
          "sub_module": null
        }
      ]
    },
    {
      "description": "å½“é…ç½®æ–‡ä»¶ config.toml ä¸å­˜åœ¨æ—¶ï¼Œç³»ç»Ÿè‡ªåŠ¨åˆ›å»ºé»˜è®¤é…ç½®ï¼Œå†™å…¥ç£ç›˜ï¼Œç¡®ä¿åº”ç”¨å¯æ— çŠ¶æ€å¯åŠ¨ã€‚è¯¥æµç¨‹ä¿éšœäº†å·¥å…·çš„å¼€ç®±å³ç”¨æ€§ï¼Œé™ä½ç”¨æˆ·ä½¿ç”¨é—¨æ§›ã€‚",
      "entry_point": "é¦–æ¬¡è¿è¡Œæ—¶æ£€æµ‹åˆ° config.toml ä¸å­˜åœ¨",
      "importance": 8.0,
      "involved_domains_count": 2,
      "name": "é…ç½®åˆå§‹åŒ–ä¸è‡ªåŠ¨ç”Ÿæˆæµç¨‹",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "é…ç½®ç®¡ç†åŸŸ",
          "operation": "æ£€æµ‹é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œè‹¥ä¸å­˜åœ¨åˆ™åŠ è½½å†…ç½®é»˜è®¤é…ç½®æ¨¡æ¿",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "é…ç½®ç®¡ç†åŸŸ",
          "operation": "å°†é»˜è®¤é…ç½®åºåˆ—åŒ–ä¸º TOML æ ¼å¼å¹¶å†™å…¥ src ç›®å½•ä¸‹çš„ config.toml æ–‡ä»¶",
          "step": 2,
          "sub_module": null
        }
      ]
    }
  ],
  "confidence_score": 0.95,
  "domain_modules": [
    {
      "code_paths": [
        "src/config.rs"
      ],
      "complexity": 7.0,
      "description": "è´Ÿè´£åº”ç”¨ç¨‹åºæ‰€æœ‰é…ç½®çš„åŠ è½½ã€åˆå¹¶ä¸ç®¡ç†ï¼ŒåŒ…æ‹¬å‘½ä»¤è¡Œå‚æ•°ã€é…ç½®æ–‡ä»¶ã€ç¯å¢ƒå˜é‡çš„ä¼˜å…ˆçº§å¤„ç†ï¼Œæ˜¯ç³»ç»Ÿè¡Œä¸ºçš„å†³ç­–ä¸­æ¢ã€‚æä¾›ç»“æ„åŒ–é…ç½®æ¨¡å‹ï¼Œç¡®ä¿å„æ¨¡å—è·å–ä¸€è‡´ã€æœ‰æ•ˆçš„é…ç½®æ•°æ®ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 9.0,
      "name": "é…ç½®ç®¡ç†åŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/markdown_scanner.rs"
      ],
      "complexity": 4.0,
      "description": "è´Ÿè´£é€’å½’éå†æŒ‡å®šç›®å½•ï¼Œè¯†åˆ«å¹¶æ”¶é›†æ‰€æœ‰ Markdown æ–‡ä»¶è·¯å¾„ï¼Œæ˜¯æ–‡æ¡£å¤„ç†çš„å‰ç½®å…¥å£ã€‚å…¶è®¾è®¡ä¸ºæ— çŠ¶æ€å·¥å…·ï¼Œä»…ä¾èµ–æ ‡å‡†åº“ï¼Œç¡®ä¿é«˜æ•ˆã€ç¨³å®šã€å¯ç§»æ¤ã€‚",
      "domain_type": "å·¥å…·æ”¯æ’‘åŸŸ",
      "importance": 6.0,
      "name": "æ–‡ä»¶æ‰«æåŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/mermaid_validator.rs"
      ],
      "complexity": 8.0,
      "description": "ä¸“é—¨è´Ÿè´£ Mermaid å›¾è¡¨è¯­æ³•çš„éªŒè¯ä¸é”™è¯¯åˆ†ç±»ï¼Œå°è£…åº•å±‚ mermaid-rs å¼•æ“ï¼Œæä¾›ä¸šåŠ¡å‹å¥½çš„é”™è¯¯æšä¸¾ï¼Œæ˜¯ä¿è¯ä¿®å¤å‡†ç¡®æ€§çš„å…³é”®è´¨é‡å…³å¡ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 9.0,
      "name": "è¯­æ³•éªŒè¯åŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/ai_fixer.rs"
      ],
      "complexity": 8.0,
      "description": "ä½œä¸ºæ™ºèƒ½ä»£ç†ï¼Œè´Ÿè´£è°ƒç”¨è¿œç¨‹ LLM API å®ç° Mermaid ä»£ç çš„è‡ªåŠ¨ä¿®å¤ã€‚å…·å¤‡è¯·æ±‚æ„å»ºã€å“åº”è§£æã€é”™è¯¯å®¹é”™ä¸æ ¼å¼å…¼å®¹èƒ½åŠ›ï¼Œæ˜¯ç³»ç»Ÿæ™ºèƒ½åŒ–çš„æ ¸å¿ƒä½“ç°ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 9.0,
      "name": "AIä¿®å¤åŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/processor.rs"
      ],
      "complexity": 6.0,
      "description": "åè°ƒæ•´ä¸ªä¿®å¤æµç¨‹ï¼Œæ•´åˆæ‰«æã€éªŒè¯ã€ä¿®å¤ç­‰æ¨¡å—çš„è¾“å‡ºï¼Œæ§åˆ¶æ‰§è¡Œé€»è¾‘ï¼ˆå¦‚æ˜¯å¦å†™å›æ–‡ä»¶ï¼‰ï¼Œå¹¶è´Ÿè´£æœ€ç»ˆç»Ÿè®¡ä¿¡æ¯çš„è¾“å‡ºã€‚æ˜¯ä¸šåŠ¡æµç¨‹çš„â€˜æŒ‡æŒ¥ä¸­å¿ƒâ€™ï¼Œä¸åŒ…å«å…·ä½“ä¸šåŠ¡é€»è¾‘ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 8.0,
      "name": "å¤„ç†åè°ƒåŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/cli.rs"
      ],
      "complexity": 5.0,
      "description": "ä½œä¸ºç”¨æˆ·äº¤äº’çš„å”¯ä¸€å…¥å£ï¼Œè´Ÿè´£è§£æå‘½ä»¤è¡Œå‚æ•°å¹¶å°†å…¶æ˜ å°„ä¸ºå†…éƒ¨é…ç½®å¯¹è±¡ã€‚å…¶æ ¸å¿ƒä»·å€¼æ˜¯æä¾›çµæ´»ã€å¯æ‰©å±•çš„ç”¨æˆ·æ¥å£ï¼Œæ”¯æŒé…ç½®ä¼˜å…ˆçº§ç®¡ç†ã€‚",
      "domain_type": "å·¥å…·æ”¯æ’‘åŸŸ",
      "importance": 7.0,
      "name": "CLIå…¥å£åŸŸ",
      "sub_modules": []
    },
    {
      "code_paths": [
        "src/utils.rs"
      ],
      "complexity": 3.0,
      "description": "æä¾›é€šç”¨å·¥å…·å‡½æ•°ï¼Œå¦‚ä» Markdown å†…å®¹ä¸­æå– Mermaid ä»£ç å—ã€æ ¼å¼åŒ–è¾“å‡ºç»Ÿè®¡ä¿¡æ¯ã€‚è¿™äº›å‡½æ•°ä¸ºä¸Šå±‚æ¨¡å—æä¾›çº¯å‡½æ•°å¼è¾…åŠ©èƒ½åŠ›ï¼Œä¸å‚ä¸æ ¸å¿ƒæµç¨‹æ§åˆ¶ã€‚",
      "domain_type": "å·¥å…·æ”¯æ’‘åŸŸ",
      "importance": 5.0,
      "name": "å·¥å…·æ”¯æŒåŸŸ",
      "sub_modules": []
    }
  ],
  "domain_relations": [
    {
      "description": "CLI æ¨¡å—è§£æç”¨æˆ·å‚æ•°åï¼Œå°†ç»“æœè½¬æ¢ä¸º Config é…ç½®å¯¹è±¡ï¼Œä½œä¸ºåç»­æ‰€æœ‰æ¨¡å—çš„è¾“å…¥æºã€‚",
      "from_domain": "CLIå…¥å£åŸŸ",
      "relation_type": "æ•°æ®ä¾èµ–",
      "strength": 9.0,
      "to_domain": "é…ç½®ç®¡ç†åŸŸ"
    },
    {
      "description": "æ–‡ä»¶æ‰«ææ¨¡å—ä¾èµ–é…ç½®ä¸­çš„ç›®å½•è·¯å¾„ã€æ’é™¤è§„åˆ™ï¼ˆå¦‚ .gitï¼‰ç­‰å‚æ•°ï¼Œå†³å®šæ‰«æèŒƒå›´ã€‚",
      "from_domain": "é…ç½®ç®¡ç†åŸŸ",
      "relation_type": "é…ç½®ä¾èµ–",
      "strength": 7.0,
      "to_domain": "æ–‡ä»¶æ‰«æåŸŸ"
    },
    {
      "description": "è¯­æ³•éªŒè¯æ¨¡å—ä¾èµ–é…ç½®ä¸­çš„è¶…æ—¶æ—¶é—´ç­‰å‚æ•°ï¼Œæ§åˆ¶éªŒè¯è¡Œä¸ºã€‚",
      "from_domain": "é…ç½®ç®¡ç†åŸŸ",
      "relation_type": "é…ç½®ä¾èµ–",
      "strength": 8.0,
      "to_domain": "è¯­æ³•éªŒè¯åŸŸ"
    },
    {
      "description": "AIä¿®å¤æ¨¡å—å¿…é¡»ä¾èµ–é…ç½®ä¸­çš„ LLM API å¯†é’¥ã€æ¨¡å‹åç§°å’ŒåŸºç¡€ URL æ‰èƒ½å‘èµ·è¯·æ±‚ã€‚",
      "from_domain": "é…ç½®ç®¡ç†åŸŸ",
      "relation_type": "é…ç½®ä¾èµ–",
      "strength": 9.0,
      "to_domain": "AIä¿®å¤åŸŸ"
    },
    {
      "description": "å¤„ç†åè°ƒæ¨¡å—ä¾èµ–é…ç½®å†³å®šæ˜¯å¦å¯ç”¨ä¿®å¤ã€æ˜¯å¦å†™å›æ–‡ä»¶ç­‰å…³é”®æ‰§è¡Œç­–ç•¥ã€‚",
      "from_domain": "é…ç½®ç®¡ç†åŸŸ",
      "relation_type": "é…ç½®ä¾èµ–",
      "strength": 8.0,
      "to_domain": "å¤„ç†åè°ƒåŸŸ"
    },
    {
      "description": "CLI è§£æåè°ƒç”¨å¤„ç†åè°ƒæ¨¡å—çš„ä¸»å¤„ç†å‡½æ•°ï¼Œå¯åŠ¨æ•´ä¸ªä¿®å¤æµç¨‹ã€‚",
      "from_domain": "CLIå…¥å£åŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 8.0,
      "to_domain": "å¤„ç†åè°ƒåŸŸ"
    },
    {
      "description": "å¤„ç†åè°ƒæ¨¡å—ä¸»åŠ¨è°ƒç”¨æ–‡ä»¶æ‰«ææ¨¡å—ï¼Œè·å–å¾…å¤„ç†çš„ Markdown æ–‡ä»¶åˆ—è¡¨ã€‚",
      "from_domain": "å¤„ç†åè°ƒåŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 9.0,
      "to_domain": "æ–‡ä»¶æ‰«æåŸŸ"
    },
    {
      "description": "å¤„ç†åè°ƒæ¨¡å—å¯¹æ¯ä¸ªæ‰«æåˆ°çš„æ–‡ä»¶è°ƒç”¨è¯­æ³•éªŒè¯æ¨¡å—ï¼Œåˆ¤æ–­å›¾è¡¨æ˜¯å¦æœ‰æ•ˆã€‚",
      "from_domain": "å¤„ç†åè°ƒåŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 9.0,
      "to_domain": "è¯­æ³•éªŒè¯åŸŸ"
    },
    {
      "description": "å½“é…ç½®å…è®¸ä¿®å¤ä¸”éªŒè¯å¤±è´¥æ—¶ï¼Œå¤„ç†åè°ƒæ¨¡å—è°ƒç”¨ AI ä¿®å¤æ¨¡å—è¿›è¡Œè‡ªåŠ¨ä¿®å¤ã€‚",
      "from_domain": "å¤„ç†åè°ƒåŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 8.0,
      "to_domain": "AIä¿®å¤åŸŸ"
    },
    {
      "description": "å¤„ç†åè°ƒæ¨¡å—è°ƒç”¨å·¥å…·æ”¯æŒæ¨¡å—ä¸­çš„ print_statistics å‡½æ•°è¾“å‡ºæœ€ç»ˆç»“æœã€‚",
      "from_domain": "å¤„ç†åè°ƒåŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 7.0,
      "to_domain": "å·¥å…·æ”¯æŒåŸŸ"
    },
    {
      "description": "æ–‡ä»¶æ‰«ææ¨¡å—åœ¨æå–æ–‡ä»¶å†…å®¹æ—¶ï¼Œè°ƒç”¨ extract_mermaid_blocks å·¥å…·å‡½æ•°æ¥å®šä½ä»£ç å—ã€‚",
      "from_domain": "æ–‡ä»¶æ‰«æåŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 6.0,
      "to_domain": "å·¥å…·æ”¯æŒåŸŸ"
    },
    {
      "description": "AIä¿®å¤æ¨¡å—åœ¨æ„å»ºè¯·æ±‚æ—¶ï¼Œéœ€è¯»å–é…ç½®ä¸­çš„ API å¯†é’¥ã€æ¨¡å‹ç­‰ä¿¡æ¯ã€‚",
      "from_domain": "AIä¿®å¤åŸŸ",
      "relation_type": "æ•°æ®ä¾èµ–",
      "strength": 9.0,
      "to_domain": "é…ç½®ç®¡ç†åŸŸ"
    },
    {
      "description": "è¯­æ³•éªŒè¯æ¨¡å—åœ¨åˆå§‹åŒ–æ—¶è¯»å–é…ç½®ä¸­çš„è¶…æ—¶å‚æ•°ã€‚",
      "from_domain": "è¯­æ³•éªŒè¯åŸŸ",
      "relation_type": "æ•°æ®ä¾èµ–",
      "strength": 7.0,
      "to_domain": "é…ç½®ç®¡ç†åŸŸ"
    }
  ]
}
```

### å·¥ä½œæµè°ƒç ”æŠ¥å‘Š
åŒ…å«å¯¹ä»£ç åº“çš„é™æ€åˆ†æç»“æœå’Œä¸šåŠ¡æµç¨‹åˆ†æã€‚

```json
{
  "main_workflow": {
    "description": "ç”¨æˆ·é€šè¿‡å‘½ä»¤è¡ŒæŒ‡å®šç›®å½•ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‰«ææ‰€æœ‰ Markdown æ–‡ä»¶ï¼Œæå–å…¶ä¸­çš„ Mermaid å›¾è¡¨ï¼ŒéªŒè¯è¯­æ³•æœ‰æ•ˆæ€§ï¼Œå¹¶å¯¹æ— æ•ˆå›¾è¡¨è°ƒç”¨ AI æ¨¡å‹è¿›è¡Œæ™ºèƒ½ä¿®å¤ï¼Œæœ€ç»ˆè¾“å‡ºç»Ÿè®¡æŠ¥å‘Šã€‚è¯¥æµç¨‹æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒä»·å€¼è·¯å¾„ï¼Œç›´æ¥å®ç°è‡ªåŠ¨åŒ–æ–‡æ¡£è´¨é‡æå‡ã€‚",
    "flowchart_mermaid": "graph TD\n    A[ç”¨æˆ·æ‰§è¡Œå‘½ä»¤: mermaid-fixer --path <dir>] --> B[CLIå…¥å£åŸŸè§£æå‚æ•°]\n    B --> C[é…ç½®ç®¡ç†åŸŸåŠ è½½å¹¶åˆå¹¶é…ç½®ï¼ˆCLI/æ–‡ä»¶/ç¯å¢ƒå˜é‡ï¼‰]\n    C --> D[å¤„ç†åè°ƒåŸŸå¯åŠ¨ä¸»æµç¨‹]\n    D --> E[æ–‡ä»¶æ‰«æåŸŸé€’å½’æ‰«æç›®å½•ï¼Œæ”¶é›†æ‰€æœ‰.md/.markdownæ–‡ä»¶]\n    E --> F[å¯¹æ¯ä¸ªæ–‡ä»¶ï¼šæå–Mermaidä»£ç å—]\n    F --> G[è¯­æ³•éªŒè¯åŸŸéªŒè¯æ¯ä¸ªä»£ç å—è¯­æ³•æœ‰æ•ˆæ€§]\n    G --> H{æ˜¯å¦æœ‰æ•ˆï¼Ÿ}\n    H -- æ˜¯ --> I[è·³è¿‡ï¼Œè®°å½•æˆåŠŸ]\n    H -- å¦ --> J[AIä¿®å¤åŸŸè°ƒç”¨LLM APIè¯·æ±‚ä¿®å¤]\n    J --> K[å¤„ç†åè°ƒåŸŸåˆ¤æ–­æ˜¯å¦å¯ç”¨å†™å›]\n    K -- æ˜¯ --> L[å°†ä¿®å¤åä»£ç å†™å›åŸæ–‡ä»¶]\n    K -- å¦ --> M[ä»…è®°å½•ä¿®å¤å»ºè®®]\n    I --> N[æ±‡æ€»æ‰€æœ‰å¤„ç†ç»“æœ]\n    M --> N\n    L --> N\n    N --> O[å·¥å…·æ”¯æŒåŸŸè¾“å‡ºç»Ÿè®¡æŠ¥å‘Š]\n    O --> P[æµç¨‹ç»“æŸ]",
    "name": "Mermaid æ–‡æ¡£æ‰¹é‡ä¿®å¤æµç¨‹"
  },
  "other_important_workflows": [
    {
      "description": "å½“é…ç½®æ–‡ä»¶ config.toml ä¸å­˜åœ¨æ—¶ï¼Œç³»ç»Ÿè‡ªåŠ¨åˆ›å»ºé»˜è®¤é…ç½®ï¼Œå†™å…¥ç£ç›˜ï¼Œç¡®ä¿åº”ç”¨å¯æ— çŠ¶æ€å¯åŠ¨ã€‚è¯¥æµç¨‹ä¿éšœäº†å·¥å…·çš„å¼€ç®±å³ç”¨æ€§ï¼Œé™ä½ç”¨æˆ·ä½¿ç”¨é—¨æ§›ã€‚",
      "flowchart_mermaid": "graph TD\n    A[é¦–æ¬¡è¿è¡Œç³»ç»Ÿ] --> B[é…ç½®ç®¡ç†åŸŸæ£€æµ‹config.tomlæ˜¯å¦å­˜åœ¨]\n    B -- å­˜åœ¨ --> C[åŠ è½½é…ç½®ï¼Œè·³è¿‡æœ¬æµç¨‹]\n    B -- ä¸å­˜åœ¨ --> D[åŠ è½½å†…ç½®é»˜è®¤é…ç½®æ¨¡æ¿]\n    D --> E[åºåˆ—åŒ–ä¸ºTOMLæ ¼å¼]\n    E --> F[å†™å…¥å½“å‰ç›®å½•ä¸‹çš„config.tomlæ–‡ä»¶]\n    F --> G[æµç¨‹ç»“æŸï¼Œç»§ç»­ä¸»æµç¨‹]",
      "name": "é…ç½®åˆå§‹åŒ–ä¸è‡ªåŠ¨ç”Ÿæˆæµç¨‹"
    }
  ]
}
```

### ä»£ç æ´å¯Ÿæ•°æ®
æ¥è‡ªé¢„å¤„ç†é˜¶æ®µçš„ä»£ç åˆ†æç»“æœï¼ŒåŒ…å«å‡½æ•°ã€ç±»å’Œæ¨¡å—çš„å®šä¹‰ã€‚

```json
[
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "src/main.rs",
      "functions": [
        "main"
      ],
      "importance_score": 1.0,
      "interfaces": [],
      "name": "main.rs",
      "source_summary": "use clap::Parser;\nuse std::process;\n\nmod cli;\nmod config;\nmod markdown_scanner;\nmod mermaid_validator;\nmod ai_fixer;\nmod processor;\nmod utils;\n\nuse cli::Args;\nuse processor::MermaidProcessor;\nuse utils::print_statistics;\n\n#[tokio::main]\nasync fn main() {\n    let args = Args::parse();\n    \n    // æå–éœ€è¦çš„å€¼\n    let directory = args.directory.clone();\n    let dry_run = args.dry_run;\n    let verbose = args.verbose;\n    \n    // è§£æé…ç½®\n    let config = match args.to_config() {\n        Ok(config) => config,\n        Err(e) => {\n            eprintln!(\"âŒ é…ç½®é”™è¯¯: {}\", e);\n            process::exit(1);\n        }\n    };\n\n    // åˆ›å»ºå¤„ç†å™¨\n    let processor = match MermaidProcessor::new(&config, dry_run, verbose).await {\n        Ok(processor) => processor,\n        Err(e) => {\n            eprintln!(\"âŒ åˆå§‹åŒ–å¤±è´¥: {}\", e);\n            process::exit(1);\n        }\n    };\n\n    // å¤„ç†ç›®å½•\n    let result = match processor.process_directory(directory, dry_run).await {\n        Ok(result) => result,\n        Err(e) => {\n            eprintln!(\"âŒ å¤„ç†å¤±è´¥: {}\", e);\n            process::exit(1);\n        }\n    };\n\n    // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯\n    print_statistics(&result, dry_run);\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.9,
      "coupling_factor": 0.7,
      "cyclomatic_complexity": 4.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 54,
      "number_of_classes": 0,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "clap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "std::process",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "cli",
        "path": "./src/cli.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "config",
        "path": "./src/config.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "mermaid_validator",
        "path": "./src/mermaid_validator.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "ai_fixer",
        "path": "./src/ai_fixer.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "processor",
        "path": "./src/processor.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "utils",
        "path": "./src/utils.rs",
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "markdown_scanner",
        "path": "./src/markdown_scanner.rs",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": false,
        "line_number": null,
        "name": "Args",
        "path": "./src/cli.rs",
        "version": null
      },
      {
        "dependency_type": "struct",
        "is_external": false,
        "line_number": null,
        "name": "MermaidProcessor",
        "path": "./src/processor.rs",
        "version": null
      }
    ],
    "detailed_description": "main.rs æ˜¯é¡¹ç›®çš„æ‰§è¡Œå…¥å£ï¼Œè´Ÿè´£åè°ƒæ•´ä¸ªåº”ç”¨ç¨‹åºçš„å¯åŠ¨æµç¨‹ã€‚å®ƒé€šè¿‡è§£æå‘½ä»¤è¡Œå‚æ•°ï¼ˆCLIï¼‰è·å–ç”¨æˆ·é…ç½®ï¼ŒåŠ è½½é…ç½®æ–‡ä»¶ï¼ˆconfig.tomlï¼‰ï¼Œåˆå§‹åŒ– MermaidProcessor å¤„ç†å™¨ï¼Œå¹¶è°ƒç”¨å…¶å¼‚æ­¥æ–¹æ³•å¤„ç†æŒ‡å®šç›®å½•ä¸‹çš„ Markdown æ–‡ä»¶ã€‚æ•´ä¸ªæµç¨‹é‡‡ç”¨é”™è¯¯é©±åŠ¨çš„ç»“æ„ï¼Œæ‰€æœ‰å…³é”®æ“ä½œï¼ˆé…ç½®åŠ è½½ã€å¤„ç†å™¨åˆå§‹åŒ–ã€ç›®å½•å¤„ç†ï¼‰å‡ä½¿ç”¨ match è¡¨è¾¾å¼è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œå¤±è´¥æ—¶æ‰“å°é”™è¯¯ä¿¡æ¯å¹¶é€€å‡ºè¿›ç¨‹ã€‚æœ€ç»ˆè¾“å‡ºå¤„ç†ç»Ÿè®¡ä¿¡æ¯ã€‚è¯¥ç»„ä»¶ä¸åŒ…å«ä¸šåŠ¡é€»è¾‘æœ¬èº«ï¼Œè€Œæ˜¯ä½œä¸ºâ€˜èƒ¶æ°´ä»£ç â€™è¿æ¥å„æ¨¡å—ï¼Œæ˜¯æ•´ä¸ªåº”ç”¨çš„å¯åŠ¨ä¸­æ¢ã€‚",
    "interfaces": [],
    "responsibilities": [
      "è§£æå‘½ä»¤è¡Œå‚æ•°å¹¶è½¬æ¢ä¸ºé…ç½®å¯¹è±¡",
      "åˆå§‹åŒ– MermaidProcessor å¤„ç†å™¨å®ä¾‹",
      "åè°ƒå¼‚æ­¥å¤„ç†æµç¨‹ï¼Œè°ƒç”¨ processor.process_directory() æ‰§è¡Œæ ¸å¿ƒä»»åŠ¡",
      "ç»Ÿä¸€å¤„ç†å…³é”®æ“ä½œä¸­çš„é”™è¯¯å¹¶ä¼˜é›…é€€å‡º",
      "è¾“å‡ºæœ€ç»ˆçš„å¤„ç†ç»Ÿè®¡ä¿¡æ¯"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "config",
      "description": null,
      "file_path": "src/config.rs",
      "functions": [
        "load"
      ],
      "importance_score": 0.9,
      "interfaces": [
        "Config",
        "LlmConfig",
        "MermaidConfig"
      ],
      "name": "config.rs",
      "source_summary": "use serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::path::Path;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Config {\n    pub llm: LlmConfig,\n    pub mermaid: MermaidConfig,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct LlmConfig {\n    pub provider: String,\n    pub model: String,\n    pub api_key: Option<String>,\n    pub base_url: Option<String>,\n    pub max_tokens: Option<u32>,\n    pub temperature: Option<f32>,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct MermaidConfig {\n    pub timeout_seconds: Option<u64>,\n    pub max_retries: Option<u32>,\n}\n\nimpl Default for Config {\n    fn default() -> Self {\n        Self {\n            llm: LlmConfig {\n                provider: \"mistral\".to_string(),\n                model: \"mistral-small-latest\".to_string(),\n                api_key: None,\n                base_url: None,\n                max_tokens: Some(65536),\n                temperature: Some(0.1),\n            },\n            mermaid: MermaidConfig {\n                timeout_seconds: Some(120),\n                max_retries: Some(3),\n            },\n        }\n    }\n}\n\nimpl Config {\n    pub fn load<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {\n        let path = path.as_ref();\n        \n        if !path.exists() {\n            // å¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶\n            let default_config = Self::default();\n            let toml_content = toml::to_string_pretty(&default_config)?;\n            fs::write(path, toml_content)?;\n            println!(\"ğŸ“ å·²åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶: {}\", path.display());\n            return Ok(default_config);\n        }\n\n        let content = fs::read_to_string(path)?;\n        let mut config: Config = toml::from_str(&content)?;\n        \n        // ä»ç¯å¢ƒå˜é‡ä¸­è¯»å–APIå¯†é’¥ï¼ˆå¦‚æœé…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰è®¾ç½®ï¼‰\n        if config.llm.api_key.is_none() {\n            config.llm.api_key = std::env::var(\"LITHO_LLM_API_KEY\").ok();\n        }\n\n        Ok(config)\n    }\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.95,
      "coupling_factor": 0.3,
      "cyclomatic_complexity": 4.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 69,
      "number_of_classes": 3,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "toml",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": null,
        "name": "std::fs",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "è¯¥ç»„ä»¶è´Ÿè´£åº”ç”¨ç¨‹åºçš„é…ç½®ç®¡ç†ï¼Œæä¾›ç»“æ„åŒ–é…ç½®æ¨¡å‹ï¼ˆConfigã€LlmConfigã€MermaidConfigï¼‰å¹¶å®ç°ä»TOMLæ–‡ä»¶åŠ è½½é…ç½®çš„é€»è¾‘ã€‚æ”¯æŒé»˜è®¤é…ç½®è‡ªåŠ¨ç”Ÿæˆã€ç¯å¢ƒå˜é‡è¦†ç›–ï¼ˆLITHO_LLM_API_KEYï¼‰ä»¥åŠé”™è¯¯å¤„ç†ã€‚å½“é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æ—¶ï¼Œè‡ªåŠ¨åˆ›å»ºé»˜è®¤é…ç½®å¹¶å†™å…¥ç£ç›˜ï¼Œç¡®ä¿åº”ç”¨å¯åŠ¨æ—¶å§‹ç»ˆæœ‰æœ‰æ•ˆé…ç½®ã€‚ä½¿ç”¨serdeè¿›è¡Œåºåˆ—åŒ–/ååºåˆ—åŒ–ï¼Œæå‡é…ç½®è¯»å†™æ•ˆç‡ä¸å¯ç»´æŠ¤æ€§ã€‚",
    "interfaces": [
      {
        "description": null,
        "interface_type": "struct",
        "name": "Config",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "llm",
            "param_type": "LlmConfig"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "mermaid",
            "param_type": "MermaidConfig"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "LlmConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "provider",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "api_key",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "base_url",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "max_tokens",
            "param_type": "Option<u32>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "temperature",
            "param_type": "Option<f32>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": null,
        "interface_type": "struct",
        "name": "MermaidConfig",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "timeout_seconds",
            "param_type": "Option<u64>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "max_retries",
            "param_type": "Option<u32>"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "å®šä¹‰åº”ç”¨é…ç½®æ•°æ®ç»“æ„ï¼ˆConfigã€LlmConfigã€MermaidConfigï¼‰",
      "ä»TOMLæ–‡ä»¶åŠ è½½é…ç½®å¹¶å¤„ç†æ–‡ä»¶ä¸å­˜åœ¨åœºæ™¯",
      "è‡ªåŠ¨ç”Ÿæˆé»˜è®¤é…ç½®å¹¶å†™å…¥ç£ç›˜",
      "ä»ç¯å¢ƒå˜é‡LITHO_LLM_API_KEYè¦†ç›–é…ç½®ä¸­çš„APIå¯†é’¥",
      "æä¾›ç±»å‹å®‰å…¨çš„é…ç½®è®¿é—®æ¥å£"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "src/processor.rs",
      "functions": [
        "MermaidProcessor::new",
        "MermaidProcessor::process_directory",
        "MermaidProcessor::process_file",
        "FileProcessResult::default"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "MermaidProcessor",
        "ProcessResult",
        "FileProcessResult"
      ],
      "name": "processor.rs",
      "source_summary": "use std::path::PathBuf;\n\nuse crate::config::Config;\nuse crate::markdown_scanner::MarkdownScanner;\nuse crate::mermaid_validator::MermaidValidator;\nuse crate::ai_fixer::AiFixer;\nuse crate::utils::extract_mermaid_blocks;\n\npub struct MermaidProcessor {\n    scanner: MarkdownScanner,\n    validator: MermaidValidator,\n    ai_fixer: Option<AiFixer>,\n    verbose: bool,\n}\n\npub struct ProcessResult {\n    pub total_files: usize,\n    pub total_mermaid_blocks: usize,\n    pub invalid_blocks: usize,\n    pub fixed_blocks: usize,\n}\n\nimpl MermaidProcessor {\n    pub async fn new(config: &Config, dry_run: bool, verbose: bool) -> Result<Self, Box<dyn std::error::Error>> {\n        let scanner = MarkdownScanner::new();\n        \n        let validator = MermaidValidator::with_config(config.mermaid.timeout_seconds)?;\n        \n        let ai_fixer = if dry_run {\n            None\n        } else {\n            Some(AiFixer::new(config).await?)\n        };\n\n        Ok(Self {\n            scanner,\n            validator,\n            ai_fixer,\n            verbose,\n        })\n    }\n\n    pub async fn process_directory(&self, directory: PathBuf, dry_run: bool) -> Result<ProcessResult, Box<dyn std::error::Error>> {\n        if self.verbose {\n            println!(\"ğŸš€ å¼€å§‹æ‰«æç›®å½•: {}\", directory.display());\n        }\n        \n        // æ‰«æmarkdownæ–‡ä»¶\n        let markdown_files = self.scanner.scan_directory(&directory)?;\n        \n        if self.verbose {\n            println!(\"ğŸ“„ æ‰¾åˆ° {} ä¸ªmarkdownæ–‡ä»¶\", markdown_files.len());\n        }\n\n        let mut total_mermaid_blocks = 0;\n        let mut invalid_blocks = 0;\n        let mut fixed_blocks = 0;\n\n        // å¤„ç†æ¯ä¸ªmarkdownæ–‡ä»¶\n        for file_path in &markdown_files {\n            if self.verbose {\n                println!(\"\\nğŸ“ å¤„ç†æ–‡ä»¶: {}\", file_path.display());\n            }\n            \n            let result = self.process_file(file_path, dry_run).await?;\n            \n            total_mermaid_blocks += result.total_blocks;\n            invalid_blocks += result.invalid_blocks;\n            fixed_blocks += result.fixed_blocks;\n        }\n\n        Ok(ProcessResult {\n            total_files: markdown_files.len(),\n            total_mermaid_blocks,\n            invalid_blocks,\n            fixed_blocks,\n        })\n    }\n\n    async fn process_file(&self, file_path: &PathBuf, dry_run: bool) -> Result<FileProcessResult, Box<dyn std::error::Error>> {\n        // è¯»å–æ–‡ä»¶å†…å®¹\n        let content = std::fs::read_to_string(file_path)?;\n\n        // æå–mermaidä»£ç å—\n        let mermaid_blocks = extract_mermaid_blocks(&content);\n        \n        if mermaid_blocks.is_empty() {\n            if self.verbose {\n                println!(\"   â„¹ï¸  æœªæ‰¾åˆ°mermaidä»£ç å—\");\n            }\n            return Ok(FileProcessResult::default());\n        }\n\n        if self.verbose {\n            println!(\"   ğŸ” æ‰¾åˆ° {} ä¸ªmermaidä»£ç å—\", mermaid_blocks.len());\n        }\n\n        let mut invalid_blocks = 0;\n        let mut fixed_blocks = 0;\n        let mut file_modified = false;\n        let mut new_content = content.clone();\n\n        // éªŒè¯æ¯ä¸ªmermaidä»£ç å—\n        for (index, (_start_pos, _end_pos, mermaid_code)) in mermaid_blocks.iter().enumerate() {\n            if self.verbose {\n                println!(\"      ğŸ“Š éªŒè¯ä»£ç å— {}/{}\", index + 1, mermaid_blocks.len());\n            }\n            \n            let validator = MermaidValidator::with_config(None)?;\n            \n            match validator.validate(mermaid_code) {\n                Ok(_) => {\n                    if self.verbose {\n                        println!(\"         âœ… ä»£ç å—æœ‰æ•ˆ\");\n                    }\n                }\n                Err(e) => {\n                    if self.verbose {\n                        println!(\"         âŒ ä»£ç å—æ— æ•ˆ: {}\", e);\n                    }\n                    invalid_blocks += 1;\n\n                    if !dry_run {\n                        if let Some(ai_fixer) = &self.ai_fixer {\n                            match ai_fixer.fix_mermaid(mermaid_code).await {\n                                Ok(fixed_code) => {\n                                    // éªŒè¯ä¿®å¤åçš„ä»£ç \n                                    match validator.validate(&fixed_code) {\n                                        Ok(_) => {\n                                            if self.verbose {\n                                                println!(\"         ğŸ”§ ä¿®å¤æˆåŠŸ\");\n                                            }\n                                            // æ›¿æ¢åŸå§‹ä»£ç \n                                            new_content = new_content.replace(mermaid_code, &fixed_code);\n                                            file_modified = true;\n                                            fixed_blocks += 1;\n                                        }\n                                        Err(validation_error) => {\n                                            if self.verbose {\n                                                println!(\"         âš ï¸  ä¿®å¤åçš„ä»£ç ä»ç„¶æ— æ•ˆ: {}\", validation_error);\n                                            }\n                                        }\n                                    }\n                                }\n                                Err(fix_error) => {\n                                    if self.verbose {\n                                        println!(\"         âš ï¸  AIä¿®å¤å¤±è´¥: {}\", fix_error);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // å¦‚æœæ–‡ä»¶è¢«ä¿®æ”¹ï¼Œå†™å›æ–‡ä»¶\n        if file_modified {\n            std::fs::write(file_path, new_content)?;\n            if self.verbose {\n                println!(\"   ğŸ’¾ æ–‡ä»¶å·²æ›´æ–°\");\n            }\n        }\n\n        Ok(FileProcessResult {\n            total_blocks: mermaid_blocks.len(),\n            invalid_blocks,\n            fixed_blocks,\n        })\n    }\n}\n\n#[derive(Default)]\nstruct FileProcessResult {\n    total_blocks: usize,\n    invalid_blocks: usize,\n    fixed_blocks: usize,\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.85,
      "coupling_factor": 0.7,
      "cyclomatic_complexity": 23.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 178,
      "number_of_classes": 3,
      "number_of_functions": 4
    },
    "dependencies": [
      {
        "dependency_type": "direct",
        "is_external": false,
        "line_number": 5,
        "name": "Config",
        "path": "src/config.rs",
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": false,
        "line_number": 6,
        "name": "MarkdownScanner",
        "path": "src/markdown_scanner.rs",
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": false,
        "line_number": 7,
        "name": "MermaidValidator",
        "path": "src/mermaid_validator.rs",
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": false,
        "line_number": 8,
        "name": "AiFixer",
        "path": "src/ai_fixer.rs",
        "version": null
      },
      {
        "dependency_type": "direct",
        "is_external": false,
        "line_number": 9,
        "name": "extract_mermaid_blocks",
        "path": "src/utils/extract_mermaid_blocks.rs",
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": true,
        "line_number": 1,
        "name": "std::path::PathBuf",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "MermaidProcessor æ˜¯ä¸€ä¸ªä¸“é—¨ç”¨äºæ‰«æã€éªŒè¯å’Œè‡ªåŠ¨ä¿®å¤ Markdown æ–‡ä»¶ä¸­ Mermaid å›¾è¡¨ä»£ç å—çš„å·¥å…·ç»„ä»¶ã€‚å®ƒé€šè¿‡é›†æˆ MarkdownScanner æå–æ‰€æœ‰ Mermaid ä»£ç å—ï¼Œä½¿ç”¨ MermaidValidator éªŒè¯å…¶è¯­æ³•æ­£ç¡®æ€§ï¼Œå¹¶åœ¨éå¹²è¿è¡Œæ¨¡å¼ä¸‹è°ƒç”¨ AiFixer å°è¯•è‡ªåŠ¨ä¿®å¤æ— æ•ˆçš„ä»£ç å—ã€‚è¯¥ç»„ä»¶æ”¯æŒè¯¦ç»†æ—¥å¿—è¾“å‡ºï¼Œå¯é€‰æ‹©æ€§åœ°ä¿®æ”¹åŸæ–‡ä»¶ï¼Œé€‚ç”¨äºè‡ªåŠ¨åŒ–æ–‡æ¡£è´¨é‡æ£€æŸ¥ä¸ä¿®å¤åœºæ™¯ã€‚æ ¸å¿ƒæµç¨‹åŒ…æ‹¬ï¼šæ‰«æç›®å½• â†’ æå–ä»£ç å— â†’ éªŒè¯è¯­æ³• â†’ æ¡ä»¶ä¿®å¤ â†’ å†™å›æ–‡ä»¶ã€‚å…¶è®¾è®¡æ”¯æŒé…ç½®é©±åŠ¨ï¼ˆå¦‚è¶…æ—¶ã€AIä¿®å¤å¼€å…³ï¼‰å’Œå¼‚æ­¥æ“ä½œï¼Œé€‚ç”¨äºå¤§å‹æ–‡æ¡£åº“çš„æ‰¹é‡å¤„ç†ã€‚",
    "interfaces": [
      {
        "description": "ä¸»å¤„ç†å™¨ç»“æ„ä½“ï¼Œå°è£…äº†æ‰«æã€éªŒè¯å’Œä¿®å¤é€»è¾‘ï¼Œé€šè¿‡ä¾èµ–æ³¨å…¥æ–¹å¼è§£è€¦å„å­æ¨¡å—",
        "interface_type": "struct",
        "name": "MermaidProcessor",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "scanner",
            "param_type": "MarkdownScanner"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "validator",
            "param_type": "MermaidValidator"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "ai_fixer",
            "param_type": "Option<AiFixer>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "verbose",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "è¡¨ç¤ºæ•´ä¸ªç›®å½•å¤„ç†ç»“æœçš„èšåˆç»Ÿè®¡ç»“æ„ï¼Œç”¨äºè¿”å›æ‰¹é‡å¤„ç†çš„æ¦‚è¦ä¿¡æ¯",
        "interface_type": "struct",
        "name": "ProcessResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "total_files",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_mermaid_blocks",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "invalid_blocks",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "fixed_blocks",
            "param_type": "usize"
          }
        ],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "è¡¨ç¤ºå•ä¸ªæ–‡ä»¶å¤„ç†ç»“æœçš„ç»Ÿè®¡ç»“æ„ï¼Œç”¨äº process_file æ–¹æ³•çš„è¿”å›å€¼",
        "interface_type": "struct",
        "name": "FileProcessResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "total_blocks",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "invalid_blocks",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "fixed_blocks",
            "param_type": "usize"
          }
        ],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "æ‰«ææŒ‡å®šç›®å½•ä¸‹çš„æ‰€æœ‰ Markdown æ–‡ä»¶å¹¶æå– Mermaid ä»£ç å—",
      "éªŒè¯æ¯ä¸ª Mermaid ä»£ç å—çš„è¯­æ³•æ­£ç¡®æ€§",
      "åœ¨éå¹²è¿è¡Œæ¨¡å¼ä¸‹ï¼Œè°ƒç”¨ AI æœåŠ¡è‡ªåŠ¨ä¿®å¤æ— æ•ˆçš„ Mermaid ä»£ç å—",
      "è®°å½•å¤„ç†ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ€»å—æ•°ã€æ— æ•ˆå—æ•°ã€ä¿®å¤å—æ•°ï¼‰å¹¶é€‰æ‹©æ€§åœ°å†™å›ä¿®æ”¹åçš„æ–‡ä»¶",
      "æä¾›è¯¦ç»†æ—¥å¿—è¾“å‡ºä»¥æ”¯æŒè°ƒè¯•å’Œç”¨æˆ·åé¦ˆ"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "util",
      "description": null,
      "file_path": "src/markdown_scanner.rs",
      "functions": [
        "new",
        "scan_directory",
        "scan_recursive",
        "is_markdown_file",
        "should_skip_directory"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "markdown_scanner.rs",
      "source_summary": "use std::fs;\nuse std::path::{Path, PathBuf};\n\npub struct MarkdownScanner {\n    // å¯ä»¥æ·»åŠ é…ç½®é€‰é¡¹ï¼Œæ¯”å¦‚å¿½ç•¥çš„ç›®å½•ç­‰\n}\n\nimpl MarkdownScanner {\n    pub fn new() -> Self {\n        Self {}\n    }\n\n    /// æ‰«ææŒ‡å®šç›®å½•ä¸‹çš„æ‰€æœ‰markdownæ–‡ä»¶\n    pub fn scan_directory<P: AsRef<Path>>(&self, dir: P) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>> {\n        let mut markdown_files = Vec::new();\n        self.scan_recursive(dir.as_ref(), &mut markdown_files)?;\n        Ok(markdown_files)\n    }\n\n    /// é€’å½’æ‰«æç›®å½•\n    fn scan_recursive(&self, dir: &Path, files: &mut Vec<PathBuf>) -> Result<(), Box<dyn std::error::Error>> {\n        if !dir.is_dir() {\n            return Err(format!(\"è·¯å¾„ä¸æ˜¯ç›®å½•: {}\", dir.display()).into());\n        }\n\n        let entries = fs::read_dir(dir)?;\n\n        for entry in entries {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.is_dir() {\n                // è·³è¿‡ä¸€äº›å¸¸è§çš„ä¸éœ€è¦æ‰«æçš„ç›®å½•\n                if let Some(dir_name) = path.file_name().and_then(|n| n.to_str()) {\n                    if self.should_skip_directory(dir_name) {\n                        continue;\n                    }\n                }\n                \n                // é€’å½’æ‰«æå­ç›®å½•\n                self.scan_recursive(&path, files)?;\n            } else if path.is_file() {\n                // æ£€æŸ¥æ˜¯å¦æ˜¯markdownæ–‡ä»¶\n                if self.is_markdown_file(&path) {\n                    files.push(path);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// åˆ¤æ–­æ˜¯å¦æ˜¯markdownæ–‡ä»¶\n    fn is_markdown_file(&self, path: &Path) -> bool {\n        if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {\n            matches!(extension.to_lowercase().as_str(), \"md\" | \"markdown\")\n        } else {\n            false\n        }\n    }\n\n    /// åˆ¤æ–­æ˜¯å¦åº”è¯¥è·³è¿‡æŸä¸ªç›®å½•\n    fn should_skip_directory(&self, dir_name: &str) -> bool {\n        matches!(\n            dir_name,\n            \".git\" | \".svn\" | \".hg\" | \n            \"node_modules\" | \"target\" | \"build\" | \"dist\" |\n            \".vscode\" | \".idea\" | \".vs\" |\n            \"__pycache__\" | \".pytest_cache\" |\n            \"vendor\" | \"deps\"\n        )\n    }\n}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.95,
      "coupling_factor": 0.2,
      "cyclomatic_complexity": 9.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 73,
      "number_of_classes": 1,
      "number_of_functions": 5
    },
    "dependencies": [
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": null,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "standard_library",
        "is_external": false,
        "line_number": null,
        "name": "std::path",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "MarkdownScanner æ˜¯ä¸€ä¸ªç”¨äºé€’å½’æ‰«ææŒ‡å®šç›®å½•å¹¶æ”¶é›†æ‰€æœ‰ Markdown æ–‡ä»¶ï¼ˆ.md å’Œ .markdownï¼‰çš„å·¥å…·ç±»ã€‚å®ƒé€šè¿‡éå†ç›®å½•æ ‘ï¼Œè·³è¿‡å¸¸è§çš„ç‰ˆæœ¬æ§åˆ¶å’Œæ„å»ºç›®å½•ï¼ˆå¦‚ .gitã€node_modulesã€target ç­‰ï¼‰ï¼Œå¹¶åŸºäºæ–‡ä»¶æ‰©å±•ååˆ¤æ–­æ˜¯å¦ä¸º Markdown æ–‡ä»¶ã€‚è¯¥ç»„ä»¶ä¸ä¾èµ–å¤–éƒ¨åº“ï¼Œä»…ä½¿ç”¨æ ‡å‡†åº“çš„ fs å’Œ path æ¨¡å—ï¼Œæä¾›æ— çŠ¶æ€çš„çº¯åŠŸèƒ½æ‰«æèƒ½åŠ›ï¼Œé€‚ç”¨äºæ–‡æ¡£ç´¢å¼•ã€é™æ€ç½‘ç«™ç”Ÿæˆæˆ–å†…å®¹ç®¡ç†ç³»ç»Ÿç­‰åœºæ™¯ã€‚",
    "interfaces": [],
    "responsibilities": [
      "é€’å½’éå†æ–‡ä»¶ç³»ç»Ÿç›®å½•",
      "è¯†åˆ«å¹¶è¿‡æ»¤ Markdown æ–‡ä»¶ï¼ˆ.md/.markdownï¼‰",
      "è·³è¿‡é¢„å®šä¹‰çš„ç³»ç»Ÿ/æ„å»ºç›®å½•ï¼ˆå¦‚ .gitã€node_modules ç­‰ï¼‰",
      "å°è£…æ–‡ä»¶ç³»ç»Ÿæ“ä½œå¼‚å¸¸å¤„ç†",
      "æä¾›ç®€æ´çš„ API æ¥å£ä¾›å¤–éƒ¨è°ƒç”¨"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "specificfeature",
      "description": null,
      "file_path": "src/mermaid_validator.rs",
      "functions": [
        "with_config",
        "validate",
        "preprocess_code",
        "classify_error"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "MermaidValidator",
        "MermaidValidationError",
        "MermaidErrorType"
      ],
      "name": "mermaid_validator.rs",
      "source_summary": "use mermaid_rs::Mermaid;\nuse std::time::Duration;\n\npub struct MermaidValidator {\n    mermaid: Mermaid,\n    timeout: Duration,\n}\n\nimpl MermaidValidator {\n\n    pub fn with_config(timeout_seconds: Option<u64>) -> Result<Self, Box<dyn std::error::Error>> {\n        let mermaid = Mermaid::new()\n            .map_err(|e| format!(\"åˆå§‹åŒ–Mermaidå®ä¾‹å¤±è´¥: {}\", e))?;\n        \n        let timeout = Duration::from_secs(timeout_seconds.unwrap_or(30));\n        \n        Ok(Self {\n            mermaid,\n            timeout,\n        })\n    }\n\n    /// éªŒè¯mermaidä»£ç æ˜¯å¦æœ‰æ•ˆ\n    pub fn validate(&self, mermaid_code: &str) -> Result<(), MermaidValidationError> {\n        if mermaid_code.trim().is_empty() {\n            return Err(MermaidValidationError::EmptyCode);\n        }\n\n        // é¢„å¤„ç†ä»£ç ï¼šç§»é™¤å¯èƒ½çš„å‰åç©ºç™½å’Œæ³¨é‡Š\n        let cleaned_code = self.preprocess_code(mermaid_code);\n\n        // ä½¿ç”¨mermaid-rsè¿›è¡ŒéªŒè¯\n        match self.mermaid.render(&cleaned_code) {\n            Ok(_) => Ok(()),\n            Err(e) => {\n                // åˆ†æé”™è¯¯ç±»å‹\n                let error_message = e.to_string();\n                let error_type = self.classify_error(&error_message);\n                Err(MermaidValidationError::RenderError {\n                    message: error_message,\n                    error_type,\n                    original_code: mermaid_code.to_string(),\n                })\n            }\n        }\n    }\n\n    /// é¢„å¤„ç†mermaidä»£ç \n    fn preprocess_code(&self, code: &str) -> String {\n        code.lines()\n            .map(|line| line.trim())\n            .filter(|line| !line.is_empty() && !line.starts_with(\"%%\"))\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }\n\n    /// åˆ†ç±»é”™è¯¯ç±»å‹\n    fn classify_error(&self, error_message: &str) -> MermaidErrorType {\n        let error_lower = error_message.to_lowercase();\n        \n        if error_lower.contains(\"syntax\") || error_lower.contains(\"parse\") {\n            MermaidErrorType::SyntaxError\n        } else if error_lower.contains(\"node\") || error_lower.contains(\"vertex\") {\n            MermaidErrorType::NodeError\n        } else if error_lower.contains(\"edge\") || error_lower.contains(\"arrow\") || error_lower.contains(\"link\") {\n            MermaidErrorType::EdgeError\n        } else if error_lower.contains(\"graph\") || error_lower.contains(\"diagram\") {\n            MermaidErrorType::GraphStructureError\n        } else if error_lower.contains(\"style\") || error_lower.contains(\"class\") {\n            MermaidErrorType::StyleError\n        } else {\n            MermaidErrorType::Unknown\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum MermaidValidationError {\n    EmptyCode,\n    RenderError {\n        message: String,\n        error_type: MermaidErrorType,\n        original_code: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub enum MermaidErrorType {\n    SyntaxError,\n    NodeError,\n    EdgeError,\n    GraphStructureError,\n    StyleError,\n    Unknown,\n}\n\nimpl std::fmt::Display for MermaidValidationError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MermaidValidationError::EmptyCode => {\n                write!(f, \"Mermaidä»£ç ä¸ºç©º\")\n            }\n            MermaidValidationError::RenderError { message, error_type, .. } => {\n                write!(f, \"Mermaidæ¸²æŸ“é”™è¯¯ ({:?}): {}\", error_type, message)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for MermaidValidationError {}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.95,
      "coupling_factor": 0.3,
      "cyclomatic_complexity": 11.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 110,
      "number_of_classes": 1,
      "number_of_functions": 4
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "mermaid_rs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "stdlib",
        "is_external": true,
        "line_number": null,
        "name": "std::time::Duration",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "MermaidValidator æ˜¯ä¸€ä¸ªç”¨äºéªŒè¯ Mermaid å›¾è¡¨ä»£ç æœ‰æ•ˆæ€§çš„ä¸“ç”¨ç»„ä»¶ã€‚å®ƒå°è£…äº† mermaid-rs åº“çš„æ¸²æŸ“åŠŸèƒ½ï¼Œæä¾›é¢„å¤„ç†ï¼ˆç§»é™¤ç©ºç™½è¡Œå’Œæ³¨é‡Šï¼‰ã€é”™è¯¯åˆ†ç±»å’Œç»Ÿä¸€é”™è¯¯è¿”å›æœºåˆ¶ã€‚ç»„ä»¶é€šè¿‡ with_config æ„é€ å‡½æ•°åˆå§‹åŒ–ï¼Œæ”¯æŒè‡ªå®šä¹‰è¶…æ—¶æ—¶é—´ï¼ˆé»˜è®¤30ç§’ï¼‰ã€‚validate æ–¹æ³•æ¥æ”¶ Mermaid ä»£ç å­—ç¬¦ä¸²ï¼Œç»è¿‡é¢„å¤„ç†åè°ƒç”¨åº•å±‚æ¸²æŸ“å¼•æ“ï¼Œæ ¹æ®æ¸²æŸ“ç»“æœè¿”å›æˆåŠŸæˆ–ç»“æ„åŒ–é”™è¯¯ä¿¡æ¯ã€‚é”™è¯¯è¢«ç»†åˆ†ä¸ºè¯­æ³•ã€èŠ‚ç‚¹ã€è¾¹ã€å›¾ç»“æ„ã€æ ·å¼ç­‰ç±»å‹ï¼Œä¾¿äºä¸Šå±‚è¿›è¡Œé’ˆå¯¹æ€§å¤„ç†ã€‚è¯¥ç»„ä»¶ä¸ç›´æ¥æš´éœ²åº•å±‚åº“çš„åŸå§‹é”™è¯¯ï¼Œè€Œæ˜¯å°†å…¶è½¬æ¢ä¸ºä¸šåŠ¡å‹å¥½çš„æšä¸¾ç±»å‹ï¼Œæå‡äº†é”™è¯¯å¤„ç†çš„ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚",
    "interfaces": [
      {
        "description": "æ ¸å¿ƒéªŒè¯å™¨ç»“æ„ä½“ï¼Œå°è£… Mermaid å®ä¾‹å’Œè¶…æ—¶é…ç½®",
        "interface_type": "struct",
        "name": "MermaidValidator",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "å®šä¹‰éªŒè¯å¤±è´¥çš„ä¸¤ç§é”™è¯¯ç±»å‹ï¼šç©ºä»£ç å’Œæ¸²æŸ“é”™è¯¯",
        "interface_type": "enum",
        "name": "MermaidValidationError",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      },
      {
        "description": "ç»†ç²’åº¦åˆ†ç±»æ¸²æŸ“é”™è¯¯çš„å…·ä½“åŸå› ï¼Œå¦‚è¯­æ³•é”™è¯¯ã€èŠ‚ç‚¹é”™è¯¯ç­‰",
        "interface_type": "enum",
        "name": "MermaidErrorType",
        "parameters": [],
        "return_type": null,
        "visibility": "public"
      }
    ],
    "responsibilities": [
      "å°è£… mermaid-rs æ¸²æŸ“é€»è¾‘ï¼Œæä¾›ç»Ÿä¸€éªŒè¯æ¥å£",
      "é¢„å¤„ç† Mermaid ä»£ç ï¼ˆå»é™¤ç©ºè¡Œå’Œæ³¨é‡Šï¼‰",
      "æ™ºèƒ½åˆ†ç±»æ¸²æŸ“é”™è¯¯ç±»å‹ï¼ˆè¯­æ³•ã€èŠ‚ç‚¹ã€è¾¹ç­‰ï¼‰",
      "æä¾›ç»“æ„åŒ–é”™è¯¯æšä¸¾ï¼Œå¢å¼ºé”™è¯¯å¯è¯»æ€§å’Œå¯å¤„ç†æ€§",
      "æ”¯æŒé…ç½®åŒ–è¶…æ—¶è®¾ç½®ï¼Œæå‡ç»„ä»¶çµæ´»æ€§"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "agent",
      "description": null,
      "file_path": "src/ai_fixer.rs",
      "functions": [
        "new",
        "fix_mermaid",
        "build_prompt",
        "extract_fixed_code",
        "clean_response",
        "extract_code_block"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "ai_fixer.rs",
      "source_summary": "use serde::{Deserialize, Serialize};\n\nuse crate::config::Config;\n\npub struct AiFixer {\n    api_key: String,\n    model: String,\n    prompt_template: String,\n    base_url: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OpenAIRequest {\n    model: String,\n    messages: Vec<Message>,\n    max_tokens: Option<u32>,\n    temperature: Option<f32>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Message {\n    role: String,\n    content: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OpenAIResponse {\n    choices: Vec<Choice>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Choice {\n    message: Message,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct FixResponse {\n    fixed_code: String,\n    explanation: String,\n    changes: Option<Vec<ChangeDetail>>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct ChangeDetail {\n    #[serde(rename = \"type\")]\n    change_type: String,\n    original: String,\n    fixed: String,\n    reason: String,\n}\n\nimpl AiFixer {\n    pub async fn new(config: &Config) -> Result<Self, Box<dyn std::error::Error>> {\n        // è·å–APIå¯†é’¥\n        let api_key = config.llm.api_key.clone()\n            .ok_or(\"æœªæ‰¾åˆ°LLM APIå¯†é’¥ï¼Œè¯·é€šè¿‡å‚æ•°æˆ–é…ç½®æ–‡ä»¶æŒ‡å®š\")?;\n\n        // è¯»å–promptæ¨¡æ¿\n        let prompt_template = include_str!(\"prompt.tpl\").to_owned();\n\n        let base_url = config.llm.base_url.clone()\n            .unwrap_or_else(|| \"https://api.mistral.ai/v1\".to_string());\n\n        Ok(Self {\n            api_key,\n            model: config.llm.model.clone(),\n            prompt_template,\n            base_url,\n        })\n    }\n\n    /// ä¿®å¤mermaidä»£ç \n    pub async fn fix_mermaid(&self, mermaid_code: &str) -> Result<String, Box<dyn std::error::Error>> {\n        // æ„å»ºæç¤ºè¯\n        let prompt = self.build_prompt(mermaid_code);\n        \n        // æ„å»ºè¯·æ±‚\n        let request = OpenAIRequest {\n            model: self.model.clone(),\n            messages: vec![\n                Message {\n                    role: \"user\".to_string(),\n                    content: prompt,\n                }\n            ],\n            max_tokens: Some(65536),\n            temperature: Some(0.1),\n        };\n\n        // å‘é€HTTPè¯·æ±‚\n        let client = reqwest::Client::new();\n        let response = client\n            .post(&format!(\"{}/chat/completions\", self.base_url))\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(&request)\n            .send()\n            .await?;\n\n        if !response.status().is_success() {\n            let error_text = response.text().await?;\n            return Err(format!(\"LLM APIè¯·æ±‚å¤±è´¥: {}\", error_text).into());\n        }\n\n        let openai_response: OpenAIResponse = response.json().await?;\n        \n        if openai_response.choices.is_empty() {\n            return Err(\"LLM APIè¿”å›ç©ºå“åº”\".into());\n        }\n\n        let content = &openai_response.choices[0].message.content;\n        \n        // è§£æå“åº”ï¼Œæå–ä¿®å¤åçš„ä»£ç \n        let fixed_code = self.extract_fixed_code(content)?;\n        \n        Ok(fixed_code)\n    }\n\n    /// æ„å»ºæç¤ºè¯\n    fn build_prompt(&self, mermaid_code: &str) -> String {\n        self.prompt_template.replace(\"{{MERMAID_CODE}}\", mermaid_code)\n    }\n\n    /// ä»LLMå“åº”ä¸­æå–ä¿®å¤åçš„ä»£ç \n    fn extract_fixed_code(&self, response: &str) -> Result<String, Box<dyn std::error::Error>> {\n        // æ¸…ç†å“åº”å†…å®¹ï¼Œç§»é™¤å¯èƒ½çš„markdownä»£ç å—åŒ…è£…\n        let cleaned_response = self.clean_response(response);\n        \n        // å°è¯•è§£æJSONæ ¼å¼çš„å“åº”\n        if let Ok(fix_response) = serde_json::from_str::<FixResponse>(&cleaned_response) {\n            println!(\"         ğŸ“‹ ä¿®å¤è¯´æ˜: {}\", fix_response.explanation);\n            if let Some(changes) = &fix_response.changes {\n                for (i, change) in changes.iter().enumerate() {\n                    println!(\"         ğŸ”§ ä¿®æ”¹ {}: {} -> {}\", \n                        i + 1, change.change_type, change.reason);\n                }\n            }\n            return Ok(fix_response.fixed_code);\n        }\n\n        // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼Œå°è¯•æå–markdownä»£ç å—\n        if let Some(code) = self.extract_code_block(response) {\n            return Ok(code);\n        }\n\n        // å¦‚æœéƒ½å¤±è´¥äº†ï¼Œè¿”å›åŸå§‹å“åº”ï¼ˆå»é™¤å‰åç©ºç™½ï¼‰\n        Ok(response.trim().to_string())\n    }\n\n    /// æ¸…ç†å“åº”å†…å®¹ï¼Œç§»é™¤å¯èƒ½çš„markdownåŒ…è£…\n    fn clean_response(&self, response: &str) -> String {\n        let response = response.trim();\n        \n        // å¦‚æœå“åº”è¢«```jsonåŒ…è£…ï¼Œæå–å…¶ä¸­çš„JSONå†…å®¹\n        if response.starts_with(\"```json\") && response.ends_with(\"```\") {\n            let lines: Vec<&str> = response.lines().collect();\n            if lines.len() > 2 {\n                return lines[1..lines.len()-1].join(\"\\n\");\n            }\n        }\n        \n        // å¦‚æœå“åº”è¢«```åŒ…è£…ï¼Œæå–å…¶ä¸­çš„å†…å®¹\n        if response.starts_with(\"```\") && response.ends_with(\"```\") {\n            let lines: Vec<&str> = response.lines().collect();\n            if lines.len() > 2 {\n                return lines[1..lines.len()-1].join(\"\\n\");\n            }\n        }\n        \n        response.to_string()\n    }\n\n    /// ä»markdownæ ¼å¼çš„å“åº”ä¸­æå–ä»£ç å—\n    fn extract_code_block(&self, response: &str) -> Option<String> {\n        let lines: Vec<&str> = response.lines().collect();\n        let mut in_code_block = false;\n        let mut code_lines = Vec::new();\n        \n        for line in lines {\n            if line.trim().starts_with(\"```mermaid\") {\n                in_code_block = true;\n                continue;\n            }\n            \n            if line.trim() == \"```\" && in_code_block {\n                break;\n            }\n            \n            if in_code_block {\n                code_lines.push(line);\n            }\n        }\n        \n        if !code_lines.is_empty() {\n            Some(code_lines.join(\"\\n\"))\n        } else {\n            None\n        }\n    }\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.85,
      "coupling_factor": 0.6,
      "cyclomatic_complexity": 16.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 200,
      "number_of_classes": 1,
      "number_of_functions": 6
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": null,
        "name": "Config",
        "path": "src/config.rs",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": null,
        "name": "reqwest",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "AiFixer æ˜¯ä¸€ä¸ªæ™ºèƒ½Agentç»„ä»¶ï¼Œç”¨äºè‡ªåŠ¨ä¿®å¤Mermaidä»£ç ã€‚å®ƒé€šè¿‡è°ƒç”¨è¿œç¨‹LLMï¼ˆå¦‚Mistralï¼‰APIï¼Œå‘é€åŒ…å«åŸå§‹Mermaidä»£ç çš„æç¤ºè¯ï¼Œæ¥æ”¶ä¿®å¤åçš„å“åº”ï¼Œå¹¶ä»å“åº”ä¸­æå–æœ‰æ•ˆä»£ç ã€‚ç»„ä»¶æ”¯æŒJSONæ ¼å¼å’ŒMarkdownä»£ç å—ä¸¤ç§å“åº”æ ¼å¼ï¼Œå…·å¤‡è‡ªåŠ¨æ¸…ç†å’Œè§£æèƒ½åŠ›ã€‚å®ƒä¾èµ–å¤–éƒ¨é…ç½®ï¼ˆConfigï¼‰è·å–APIå¯†é’¥ã€æ¨¡å‹åç§°å’ŒåŸºç¡€URLï¼Œæ”¯æŒç¯å¢ƒå˜é‡æ³¨å…¥APIå¯†é’¥ï¼Œå…·æœ‰è‰¯å¥½çš„é…ç½®çµæ´»æ€§å’Œå®¹é”™æœºåˆ¶ã€‚æ ¸å¿ƒé€»è¾‘åŒ…æ‹¬æ„å»ºæç¤ºè¯ã€å‘é€HTTPè¯·æ±‚ã€å¤„ç†APIé”™è¯¯ã€è§£æå“åº”å†…å®¹ï¼ˆJSONæˆ–Markdownä»£ç å—ï¼‰å¹¶è¿”å›ä¿®å¤åçš„ä»£ç ã€‚",
    "interfaces": [],
    "responsibilities": [
      "ç®¡ç†LLM APIè¿æ¥é…ç½®ï¼ˆAPIå¯†é’¥ã€æ¨¡å‹ã€åŸºç¡€URLï¼‰",
      "æ„å»ºé’ˆå¯¹Mermaidä»£ç ä¿®å¤çš„æç¤ºè¯æ¨¡æ¿",
      "ä¸è¿œç¨‹LLMæœåŠ¡è¿›è¡ŒHTTPé€šä¿¡å¹¶å¤„ç†å“åº”",
      "æ™ºèƒ½è§£æLLMè¿”å›çš„å¤šç§æ ¼å¼å“åº”ï¼ˆJSONæˆ–Markdownä»£ç å—ï¼‰",
      "æä¾›é”™è¯¯å¤„ç†å’Œå®¹é”™æœºåˆ¶ï¼Œç¡®ä¿æœåŠ¡ç¨³å®šæ€§"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "util",
      "description": null,
      "file_path": "src/utils.rs",
      "functions": [
        "extract_mermaid_blocks",
        "print_statistics"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "utils.rs",
      "source_summary": "/// ä»markdownå†…å®¹ä¸­æå–mermaidä»£ç å—\n/// è¿”å› (å¼€å§‹ä½ç½®, ç»“æŸä½ç½®, ä»£ç å†…å®¹) çš„å…ƒç»„åˆ—è¡¨\npub fn extract_mermaid_blocks(content: &str) -> Vec<(usize, usize, String)> {\n    let mut blocks = Vec::new();\n    let lines: Vec<&str> = content.lines().collect();\n    let mut i = 0;\n\n    while i < lines.len() {\n        let line = lines[i].trim();\n        \n        // æŸ¥æ‰¾mermaidä»£ç å—å¼€å§‹æ ‡è®°\n        if line == \"```mermaid\" {\n            let start_line = i;\n            i += 1;\n            let mut mermaid_lines = Vec::new();\n            \n            // æ”¶é›†mermaidä»£ç ç›´åˆ°ç»“æŸæ ‡è®°\n            while i < lines.len() {\n                let current_line = lines[i];\n                if current_line.trim() == \"```\" {\n                    // æ‰¾åˆ°ç»“æŸæ ‡è®°\n                    let end_line = i;\n                    let mermaid_code = mermaid_lines.join(\"\\n\");\n                    \n                    // è®¡ç®—åœ¨åŸå§‹å†…å®¹ä¸­çš„ä½ç½®\n                    let start_pos = lines[..start_line].iter().map(|l| l.len() + 1).sum::<usize>();\n                    let end_pos = lines[..=end_line].iter().map(|l| l.len() + 1).sum::<usize>();\n                    \n                    blocks.push((start_pos, end_pos, mermaid_code));\n                    break;\n                }\n                mermaid_lines.push(current_line);\n                i += 1;\n            }\n        }\n        i += 1;\n    }\n\n    blocks\n}\n\n/// æ‰“å°ç»Ÿè®¡ä¿¡æ¯\npub fn print_statistics(result: &crate::processor::ProcessResult, dry_run: bool) {\n    println!(\"\\nğŸ“Š å¤„ç†å®Œæˆ:\");\n    println!(\"   ğŸ“„ å¤„ç†æ–‡ä»¶æ•°: {}\", result.total_files);\n    println!(\"   ğŸ“Š æ€»mermaidä»£ç å—æ•°: {}\", result.total_mermaid_blocks);\n    println!(\"   âŒ æ— æ•ˆä»£ç å—æ•°: {}\", result.invalid_blocks);\n    if !dry_run {\n        println!(\"   ğŸ”§ æˆåŠŸä¿®å¤æ•°: {}\", result.fixed_blocks);\n    }\n}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.95,
      "coupling_factor": 0.2,
      "cyclomatic_complexity": 6.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 51,
      "number_of_classes": 0,
      "number_of_functions": 2
    },
    "dependencies": [],
    "detailed_description": "è¯¥ç»„ä»¶åŒ…å«ä¸¤ä¸ªå·¥å…·å‡½æ•°ï¼šextract_mermaid_blocks ç”¨äºä» Markdown å†…å®¹ä¸­æå– ```mermaid ä»£ç å—ï¼Œè¿”å›æ¯ä¸ªä»£ç å—åœ¨åŸå§‹æ–‡æœ¬ä¸­çš„èµ·æ­¢ä½ç½®å’Œå†…å®¹ï¼›print_statistics ç”¨äºæ ¼å¼åŒ–è¾“å‡ºå¤„ç†ç»“æœçš„ç»Ÿè®¡ä¿¡æ¯ï¼Œä¾èµ–å¤–éƒ¨çš„ ProcessResult ç»“æ„ä½“ã€‚ä¸¤ä¸ªå‡½æ•°å‡ä¸ºæ— çŠ¶æ€å·¥å…·å‡½æ•°ï¼Œä¸ç»´æŠ¤ä»»ä½•å†…éƒ¨çŠ¶æ€ï¼Œä»…æä¾›çº¯å‡½æ•°å¼æ•°æ®å¤„ç†ä¸è¾“å‡ºèƒ½åŠ›ã€‚",
    "interfaces": [],
    "responsibilities": [
      "ä» Markdown æ–‡æœ¬ä¸­è§£æå¹¶æå– Mermaid ä»£ç å—",
      "è®¡ç®— Mermaid ä»£ç å—åœ¨åŸå§‹æ–‡æœ¬ä¸­çš„å­—ç¬¦çº§ä½ç½®",
      "æ ¼å¼åŒ–è¾“å‡ºå¤„ç†æµç¨‹çš„ç»Ÿè®¡ä¿¡æ¯",
      "æä¾›è½»é‡çº§æ—¥å¿—æ‰“å°åŠŸèƒ½ï¼Œæ”¯æŒå¹²è¿è¡Œæ¨¡å¼",
      "ä½œä¸ºé€šç”¨å·¥å…·æ”¯æŒä¸Šæ¸¸å¤„ç†å™¨çš„è°ƒè¯•ä¸åé¦ˆ"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "src/cli.rs",
      "functions": [
        "Args::to_config"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "cli.rs",
      "source_summary": "use clap::Parser;\nuse std::path::PathBuf;\n\nuse crate::config::Config;\n\n/// Mermaid Fixer - åŸºäºRustå’ŒAIçš„markdownæ–‡æ¡£ä¿®å¤å™¨\n#[derive(Parser, Debug)]\n#[command(name = \"mermaid-fixer\")]\n#[command(about = \"åŸºäºRustå’ŒAIçš„markdownæ–‡æ¡£ä¿®å¤å™¨ï¼Œç”¨äºæ‰«æå’Œä¿®å¤markdownæ–‡ä»¶ä¸­çš„mermaidå›¾è¡¨è¯­æ³•é”™è¯¯\")]\n#[command(author = \"jiangmeng03\")]\n#[command(version)]\npub struct Args {\n    /// è¦æ‰«æçš„ç›®å½•è·¯å¾„\n    #[arg(short, long, value_name = \"DIR\")]\n    pub directory: PathBuf,\n\n    /// é…ç½®æ–‡ä»¶è·¯å¾„\n    #[arg(short, long, value_name = \"FILE\", default_value = \"config.toml\")]\n    pub config: PathBuf,\n\n    /// åªæ£€æµ‹é—®é¢˜ï¼Œä¸è¿›è¡Œä¿®å¤\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// å¯ç”¨è¯¦ç»†æ—¥å¿—è¾“å‡º\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// LLMæä¾›å•† (openai, mistral, deepseekç­‰)\n    #[arg(long)]\n    pub llm_provider: Option<String>,\n\n    /// LLMæ¨¡å‹åç§°\n    #[arg(long)]\n    pub llm_model: Option<String>,\n\n    /// LLM APIå¯†é’¥\n    #[arg(long)]\n    pub llm_api_key: Option<String>,\n\n    /// LLM APIåŸºç¡€URL\n    #[arg(long)]\n    pub llm_base_url: Option<String>,\n\n    /// æœ€å¤§tokenæ•°\n    #[arg(long)]\n    pub max_tokens: Option<u32>,\n\n    /// æ¸©åº¦å‚æ•° (0.0-1.0)\n    #[arg(long)]\n    pub temperature: Option<f32>,\n\n    /// MermaidéªŒè¯è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰\n    #[arg(long)]\n    pub timeout_seconds: Option<u64>,\n\n    /// æœ€å¤§é‡è¯•æ¬¡æ•°\n    #[arg(long)]\n    pub max_retries: Option<u32>,\n}\n\nimpl Args {\n    /// å°†CLIå‚æ•°è½¬æ¢ä¸ºé…ç½®\n    pub fn to_config(self) -> Result<Config, Box<dyn std::error::Error>> {\n        let mut config = if self.config.exists() {\n            Config::load(&self.config)?\n        } else {\n            Config::default()\n        };\n\n        // è¦†ç›–LLMé…ç½®\n        if let Some(provider) = self.llm_provider {\n            config.llm.provider = provider;\n        }\n\n        if let Some(model) = self.llm_model {\n            config.llm.model = model;\n        }\n\n        if let Some(api_key) = self.llm_api_key {\n            config.llm.api_key = Some(api_key);\n        }\n\n        if let Some(base_url) = self.llm_base_url {\n            config.llm.base_url = Some(base_url);\n        }\n\n        if let Some(max_tokens) = self.max_tokens {\n            config.llm.max_tokens = Some(max_tokens);\n        }\n\n        if let Some(temperature) = self.temperature {\n            config.llm.temperature = Some(temperature);\n        }\n\n        // è¦†ç›–Mermaidé…ç½®\n        if let Some(timeout) = self.timeout_seconds {\n            config.mermaid.timeout_seconds = Some(timeout);\n        }\n\n        if let Some(retries) = self.max_retries {\n            config.mermaid.max_retries = Some(retries);\n        }\n\n        Ok(config)\n    }\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.9,
      "coupling_factor": 0.6,
      "cyclomatic_complexity": 10.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 107,
      "number_of_classes": 1,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "clap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "Config",
        "path": "crate::config::Config",
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": true,
        "line_number": null,
        "name": "PathBuf",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "è¯¥ç»„ä»¶æ˜¯Mermaid Fixeré¡¹ç›®çš„æ‰§è¡Œå…¥å£ï¼ŒåŸºäºclapåº“å®šä¹‰å‘½ä»¤è¡Œå‚æ•°è§£æç»“æ„ä½“Argsã€‚å®ƒè´Ÿè´£æ¥æ”¶ç”¨æˆ·é€šè¿‡å‘½ä»¤è¡Œä¼ é€’çš„é…ç½®å‚æ•°ï¼ˆå¦‚ç›®å½•è·¯å¾„ã€LLMæä¾›å•†ã€APIå¯†é’¥ã€è¶…æ—¶æ—¶é—´ç­‰ï¼‰ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºå†…éƒ¨Configé…ç½®å¯¹è±¡ã€‚è¯¥ç»“æ„ä½“ä¸ç›´æ¥æ‰§è¡Œæ–‡ä»¶æ‰«ææˆ–ä¿®å¤é€»è¾‘ï¼Œè€Œæ˜¯ä½œä¸ºé…ç½®æ¢çº½ï¼Œå°†CLIè¾“å…¥æ˜ å°„åˆ°ç³»ç»Ÿæ ¸å¿ƒé…ç½®ï¼Œä¾›åç»­æ¨¡å—ä½¿ç”¨ã€‚å…¶æ ¸å¿ƒä»·å€¼åœ¨äºæä¾›çµæ´»ã€å¯æ‰©å±•çš„å‘½ä»¤è¡Œæ¥å£ï¼Œæ”¯æŒè¦†ç›–é»˜è®¤é…ç½®å’Œç¯å¢ƒå˜é‡é…ç½®ï¼Œå®ç°é…ç½®ä¼˜å…ˆçº§ç®¡ç†ï¼ˆCLI > é…ç½®æ–‡ä»¶ > é»˜è®¤å€¼ï¼‰ã€‚",
    "interfaces": [],
    "responsibilities": [
      "è§£æç”¨æˆ·å‘½ä»¤è¡Œå‚æ•°",
      "å°†CLIå‚æ•°è½¬æ¢ä¸ºå†…éƒ¨Configé…ç½®å¯¹è±¡",
      "è¦†ç›–Configä¸­çš„LLMå’ŒMermaidç›¸å…³é…ç½®é¡¹",
      "æä¾›é…ç½®ä¼˜å…ˆçº§ç®¡ç†æœºåˆ¶ï¼ˆå‘½ä»¤è¡Œ > é…ç½®æ–‡ä»¶ > é»˜è®¤å€¼ï¼‰",
      "å°è£…é…ç½®åŠ è½½é€»è¾‘ï¼Œé™ä½ä¸»ç¨‹åºè€¦åˆåº¦"
    ]
  }
]
```

## Memoryå­˜å‚¨ç»Ÿè®¡

**æ€»å­˜å‚¨å¤§å°**: 297629 bytes

- **documentation**: 181282 bytes (60.9%)
- **timing**: 36 bytes (0.0%)
- **preprocess**: 53482 bytes (18.0%)
- **studies_research**: 62829 bytes (21.1%)

## ç”Ÿæˆæ–‡æ¡£ç»Ÿè®¡

ç”Ÿæˆæ–‡æ¡£æ•°é‡: 10 ä¸ª

- æ ¸å¿ƒæµç¨‹
- é¡¹ç›®æ¦‚è¿°
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_æ–‡ä»¶æ‰«æåŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_AIä¿®å¤åŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_é…ç½®ç®¡ç†åŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_CLIå…¥å£åŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_è¯­æ³•éªŒè¯åŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_å·¥å…·æ”¯æŒåŸŸ
- æ¶æ„è¯´æ˜
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_å¤„ç†åè°ƒåŸŸ
